{"ast":null,"code":"import _slicedToArray from \"B:\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n\n/**\n * Gets the current state. If the selectedValue is controlled,\n * the `value` prop is the source of truth instead of the internal state.\n */\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n  return internalState;\n}\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n  return optionComparer(option1, option2);\n}\n\n/**\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\n *\n * @param nextState The next state returned by the reducer.\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\n * @param propsRef The props with defaults applied.\n * @param lastActionRef The last action that was dispatched.\n */\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(function () {\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n    var previousState = getControlledState(internalPreviousState, propsRef.current);\n    var _propsRef$current2 = propsRef.current,\n      multiple = _propsRef$current2.multiple,\n      optionComparer = _propsRef$current2.optionComparer;\n    if (multiple) {\n      var _previousState$select;\n      var previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValue) != null ? _previousState$select : [];\n      var nextSelectedValues = nextState.selectedValue;\n      var onChange = propsRef.current.onChange;\n      if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n        onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n      }\n    } else {\n      var previousSelectedValue = previousState == null ? void 0 : previousState.selectedValue;\n      var nextSelectedValue = nextState.selectedValue;\n      var _onChange = propsRef.current.onChange;\n      if (!areOptionsEqual(nextSelectedValue, previousSelectedValue, optionComparer)) {\n        _onChange == null ? void 0 : _onChange(lastActionRef.current.event, nextSelectedValue);\n      }\n    }\n\n    // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n    lastActionRef.current = null;\n  }, [nextState.selectedValue, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n\n/**\n * @ignore - do not document.\n */\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n  var _props$current = props.current,\n    value = _props$current.value,\n    defaultValue = _props$current.defaultValue,\n    multiple = _props$current.multiple;\n  var actionRef = React.useRef(null);\n  var initialSelectedValue = (_ref = value === undefined ? defaultValue : value) != null ? _ref : multiple ? [] : null;\n  var initialState = {\n    highlightedValue: null,\n    selectedValue: initialSelectedValue\n  };\n  var combinedReducer = React.useCallback(function (state, action) {\n    actionRef.current = action;\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n  var _React$useReducer = React.useReducer(combinedReducer, initialState),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    nextState = _React$useReducer2[0],\n    dispatch = _React$useReducer2[1];\n  var dispatchWithProps = React.useCallback(function (action) {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  var previousState = React.useRef(initialState);\n  React.useEffect(function () {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}","map":null,"metadata":{},"sourceType":"module"}