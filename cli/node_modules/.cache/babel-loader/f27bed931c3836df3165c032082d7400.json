{"ast":null,"code":"import _slicedToArray from \"B:\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_useForkRef as useForkRef, unstable_useId as useId } from '@mui/utils';\nimport { ActionTypes } from './useListbox.types';\nimport defaultReducer from './defaultListboxReducer';\nimport useControllableReducer from './useControllableReducer';\nimport areArraysEqual from '../utils/areArraysEqual';\nimport useLatest from '../utils/useLatest';\nimport useTextNavigation from '../utils/useTextNavigation';\nvar defaultOptionComparer = function defaultOptionComparer(optionA, optionB) {\n  return optionA === optionB;\n};\nvar defaultIsOptionDisabled = function defaultIsOptionDisabled() {\n  return false;\n};\nvar defaultOptionStringifier = function defaultOptionStringifier(option) {\n  return typeof option === 'string' ? option : String(option);\n};\n\n/**\n * @ignore - do not document.\n */\nexport default function useListbox(props) {\n  var _props$optionIdGenera;\n  var _props$disabledItemsF = props.disabledItemsFocusable,\n    disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,\n    _props$disableListWra = props.disableListWrap,\n    disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,\n    _props$focusManagemen = props.focusManagement,\n    focusManagement = _props$focusManagemen === void 0 ? 'activeDescendant' : _props$focusManagemen,\n    idProp = props.id,\n    _props$isOptionDisabl = props.isOptionDisabled,\n    isOptionDisabled = _props$isOptionDisabl === void 0 ? defaultIsOptionDisabled : _props$isOptionDisabl,\n    externalListboxRef = props.listboxRef,\n    _props$multiple = props.multiple,\n    multiple = _props$multiple === void 0 ? false : _props$multiple,\n    _props$optionComparer = props.optionComparer,\n    optionComparer = _props$optionComparer === void 0 ? defaultOptionComparer : _props$optionComparer,\n    _props$optionStringif = props.optionStringifier,\n    optionStringifier = _props$optionStringif === void 0 ? defaultOptionStringifier : _props$optionStringif,\n    options = props.options,\n    externalReducer = props.stateReducer,\n    valueParam = props.value;\n  var id = useId(idProp);\n  var defaultIdGenerator = React.useCallback(function (_, index) {\n    return \"\".concat(id, \"-option-\").concat(index);\n  }, [id]);\n  var optionIdGenerator = (_props$optionIdGenera = props.optionIdGenerator) != null ? _props$optionIdGenera : defaultIdGenerator;\n  var propsWithDefaults = useLatest(_extends({}, props, {\n    disabledItemsFocusable: disabledItemsFocusable,\n    disableListWrap: disableListWrap,\n    focusManagement: focusManagement,\n    isOptionDisabled: isOptionDisabled,\n    multiple: multiple,\n    optionComparer: optionComparer,\n    optionStringifier: optionStringifier\n  }), [props]);\n  var listboxRef = React.useRef(null);\n  var handleRef = useForkRef(externalListboxRef, listboxRef);\n  var _useControllableReduc = useControllableReducer(defaultReducer, externalReducer, propsWithDefaults),\n    _useControllableReduc2 = _slicedToArray(_useControllableReduc, 2),\n    _useControllableReduc3 = _useControllableReduc2[0],\n    highlightedValue = _useControllableReduc3.highlightedValue,\n    selectedValue = _useControllableReduc3.selectedValue,\n    dispatch = _useControllableReduc2[1];\n  var handleTextNavigation = useTextNavigation(function (searchString, event) {\n    return dispatch({\n      type: ActionTypes.textNavigation,\n      event: event,\n      searchString: searchString\n    });\n  });\n  React.useEffect(function () {\n    // if a controlled value changes, we need to update the state to keep things in sync\n    if (valueParam !== undefined && valueParam !== selectedValue) {\n      dispatch({\n        type: ActionTypes.setValue,\n        event: null,\n        value: valueParam\n      });\n    }\n  }, [valueParam, selectedValue, dispatch]);\n  var highlightedIndex = React.useMemo(function () {\n    return highlightedValue == null ? -1 : options.findIndex(function (option) {\n      return optionComparer(option, highlightedValue);\n    });\n  }, [highlightedValue, options, optionComparer]);\n\n  // introducing refs to avoid recreating the getOptionState function on each change.\n  var latestSelectedValue = useLatest(selectedValue);\n  var latestHighlightedIndex = useLatest(highlightedIndex);\n  var previousOptions = React.useRef([]);\n  React.useEffect(function () {\n    if (areArraysEqual(previousOptions.current, options, optionComparer)) {\n      return;\n    }\n    dispatch({\n      type: ActionTypes.optionsChange,\n      event: null,\n      options: options,\n      previousOptions: previousOptions.current\n    });\n    previousOptions.current = options;\n  }, [options, optionComparer, dispatch]);\n  var setSelectedValue = React.useCallback(function (option) {\n    dispatch({\n      type: ActionTypes.setValue,\n      event: null,\n      value: option\n    });\n  }, [dispatch]);\n  var setHighlightedValue = React.useCallback(function (option) {\n    dispatch({\n      type: ActionTypes.setHighlight,\n      event: null,\n      highlight: option\n    });\n  }, [dispatch]);\n  var createHandleOptionClick = React.useCallback(function (option, other) {\n    return function (event) {\n      var _other$onClick;\n      (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);\n      if (event.defaultPrevented) {\n        return;\n      }\n      event.preventDefault();\n      dispatch({\n        type: ActionTypes.optionClick,\n        option: option,\n        event: event\n      });\n    };\n  }, [dispatch]);\n  var createHandleOptionPointerOver = React.useCallback(function (option, other) {\n    return function (event) {\n      var _other$onMouseOver;\n      (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);\n      if (event.defaultPrevented) {\n        return;\n      }\n      dispatch({\n        type: ActionTypes.optionHover,\n        option: option,\n        event: event\n      });\n    };\n  }, [dispatch]);\n  var createHandleKeyDown = function createHandleKeyDown(other) {\n    return function (event) {\n      var _other$onKeyDown;\n      (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);\n      if (event.defaultPrevented) {\n        return;\n      }\n      var keysToPreventDefault = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'];\n      if (focusManagement === 'activeDescendant') {\n        // When the child element is focused using the activeDescendant attribute,\n        // the listbox handles keyboard events on its behalf.\n        // We have to `preventDefault()` is this case to prevent the browser from\n        // scrolling the view when space is pressed or submitting forms when enter is pressed.\n        keysToPreventDefault.push(' ', 'Enter');\n      }\n      if (keysToPreventDefault.includes(event.key)) {\n        event.preventDefault();\n      }\n      dispatch({\n        type: ActionTypes.keyDown,\n        event: event\n      });\n      handleTextNavigation(event);\n    };\n  };\n  var createHandleBlur = function createHandleBlur(other) {\n    return function (event) {\n      var _other$onBlur, _listboxRef$current;\n      (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);\n      if (event.defaultPrevented) {\n        return;\n      }\n      if ((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(document.activeElement)) {\n        // focus is within the listbox\n        return;\n      }\n      dispatch({\n        type: ActionTypes.blur,\n        event: event\n      });\n    };\n  };\n  var getRootProps = function getRootProps() {\n    var otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _extends({}, otherHandlers, {\n      'aria-activedescendant': focusManagement === 'activeDescendant' && highlightedValue != null ? optionIdGenerator(highlightedValue, highlightedIndex) : undefined,\n      id: id,\n      onBlur: createHandleBlur(otherHandlers),\n      onKeyDown: createHandleKeyDown(otherHandlers),\n      role: 'listbox',\n      tabIndex: focusManagement === 'DOM' ? -1 : 0,\n      ref: handleRef\n    });\n  };\n  var getOptionState = React.useCallback(function (option) {\n    var selected;\n    var index = options.findIndex(function (opt) {\n      return optionComparer(opt, option);\n    });\n    if (multiple) {\n      var _ref;\n      selected = ((_ref = latestSelectedValue.current) != null ? _ref : []).some(function (value) {\n        return value != null && optionComparer(option, value);\n      });\n    } else {\n      selected = optionComparer(option, latestSelectedValue.current);\n    }\n    var disabled = isOptionDisabled(option, index);\n    var highlighted = latestHighlightedIndex.current === index && index !== -1;\n    return {\n      disabled: disabled,\n      highlighted: highlighted,\n      index: index,\n      selected: selected\n    };\n  }, [options, multiple, isOptionDisabled, optionComparer, latestSelectedValue, latestHighlightedIndex]);\n  var getOptionTabIndex = React.useCallback(function (optionState) {\n    if (focusManagement === 'activeDescendant') {\n      return undefined;\n    }\n    if (!optionState.highlighted) {\n      return -1;\n    }\n    if (optionState.disabled && !disabledItemsFocusable) {\n      return -1;\n    }\n    return 0;\n  }, [focusManagement, disabledItemsFocusable]);\n  var getOptionProps = React.useCallback(function (option) {\n    var otherHandlers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var optionState = getOptionState(option);\n    return _extends({}, otherHandlers, {\n      'aria-disabled': optionState.disabled || undefined,\n      'aria-selected': optionState.selected,\n      id: optionIdGenerator(option, optionState.index),\n      onClick: createHandleOptionClick(option, otherHandlers),\n      onPointerOver: createHandleOptionPointerOver(option, otherHandlers),\n      role: 'option',\n      tabIndex: getOptionTabIndex(optionState)\n    });\n  }, [optionIdGenerator, createHandleOptionClick, createHandleOptionPointerOver, getOptionTabIndex, getOptionState]);\n  React.useDebugValue({\n    highlightedOption: highlightedValue,\n    selectedOption: selectedValue\n  });\n  return {\n    getRootProps: getRootProps,\n    getOptionProps: getOptionProps,\n    getOptionState: getOptionState,\n    highlightedOption: highlightedValue,\n    selectedOption: selectedValue,\n    setSelectedValue: setSelectedValue,\n    setHighlightedValue: setHighlightedValue\n  };\n}","map":null,"metadata":{},"sourceType":"module"}